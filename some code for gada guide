GADA GUIDE 

import csv
import json
import os
import queue
import random
import smtplib
import sqlite3
import threading
import tkinter as tk
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from tkinter import messagebox, filedialog
import firebase_admin
import pyttsx3
import requests
import sounddevice as sd
from firebase_admin import credentials, firestore
from langdetect import detect
from playsound import playsound
engine = pyttsx3.init()
engine.say("Hello, welcome back!")
engine.runAndWait()
# For transformer emotion detection
try:
    from transformers import pipeline
    transformer_emotion = pipeline("text-classification", model="j-hartmann/emotion-english-distilroberta-base", return_all_scores=True)
except ImportError:
    transformer_emotion = None

# For Google Translate API - placeholder function
def translate_text(text, target_lang="en"):
    # You can add real Google Translate API integration here
    # For demo, just return text unchanged
    return text

# For Twilio SMS (placeholder values - fill with your account details)
try:
    from twilio.rest import Client
    TWILIO_ACCOUNT_SID = "your_twilio_sid"
    TWILIO_AUTH_TOKEN = "your_twilio_token"
    TWILIO_FROM_NUMBER = "+1234567890"
    TWILIO_TO_NUMBER = "+0987654321"
    twilio_client = Client(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)
except ImportError:
    twilio_client = None

# Firebase Admin Init
def init_firebase_admin():
    try:
        cred = credentials.Certificate("firebase_key.json")
        firebase_admin.initialize_app(cred)
        global db
        db = firestore.client()
        print(" Firebase connected.")
    except Exception as e:
        print(" Firebase error:", e)

# Firebase REST Auth
FIREBASE_API_KEY = "AIzaSyDEG3GftYy5twDt8MpcEyJtvcbtwnCAic4"  # Replace with your Web API Key from Firebase project settings

def firebase_sign_in(email, password):
    url = f"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key={FIREBASE_API_KEY}"
    payload = {
        "email": email,
        "password": password,
        "returnSecureToken": True
    }
    try:
        r = requests.post(url, json=payload)
        r.raise_for_status()
        return r.json()  # Contains idToken, localId (UID), email, etc
    except Exception as e:
        print("Login error:", e)
        return None

# TTS
def speak(text, lang):
    engine = pyttsx3.init()
    voices = engine.getProperty('voices')

    selected_voice = None
    for voice in voices:
        if hasattr(voice, 'languages') and voice.languages:
            language_code = voice.languages[0]
            if isinstance(language_code, bytes):
                language_code = language_code.decode('utf-8').lower()
            else:
                language_code = str(language_code).lower()

            if lang.lower() in language_code:
                selected_voice = voice.id
                break

    if selected_voice:
        engine.setProperty('voice', selected_voice)
    else:
        print(f"No matching voice found for language '{lang}', using default voice.")

    engine.say(text)
    engine.runAndWait()

# SQLite Init
def init_db():
    conn = sqlite3.connect("gada_guide_logs.db")
    c = conn.cursor()

    # Create tables if they don't exist
    c.execute('''
        CREATE TABLE IF NOT EXISTS logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT,
            text_input TEXT,
            emotion TEXT,
            intensity REAL,
            language TEXT,
            emergency INTEGER
        )
    ''')

    c.execute('''
        CREATE TABLE IF NOT EXISTS badges (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_email TEXT,
            badge TEXT,
            awarded_on TEXT
        )
    ''')
    conn.commit()
    conn.close()

#  Enhanced Emotion Detection
def get_emotion(text):
    if transformer_emotion:
        results = transformer_emotion(text)
        # results is list of dicts with label and score
        sorted_emotions = sorted(results[0], key=lambda x: x['score'], reverse=True)
        top_emotion = sorted_emotions[0]
        label = top_emotion['label'].capitalize()
        score = top_emotion['score']
        # Map to emoji (expand as needed)
        emojis = {
            "Joy": "ğŸ˜Š",
            "Sadness": "ğŸ˜¢",
            "Anger": "ğŸ˜ ",
            "Fear": "ğŸ˜¨",
            "Surprise": "ğŸ˜²",
            "Disgust": "ğŸ¤¢",
            "Neutral": "ğŸ˜"
        }
        emo_emoji = emojis.get(label, "ğŸ˜")
        return f"{emo_emoji} {label}", score
    else:
        # fallback simple keyword-based
        text = text.lower()
        happy = ["happy", "good", "great", "love", "joy", "awesome"]
        sad = ["sad", "tired", "bad", "angry", "cry", "pain"]
        if any(word in text for word in happy):
            return "ğŸ™‚ Happy", 0.7
        elif any(word in text for word in sad):
            return "ğŸ˜Ÿ Sad", 0.7
        else:
            return "ğŸ˜ Neutral", 0.5

#  Emergency Check & Alerts
def emergency_check(emotion, intensity):
    # Emergency if intense sadness, fear, anger
    emergency_emotions = ["ğŸ˜Ÿ Sadness", "ğŸ˜¢ Fear", "ğŸ˜  Anger"]
    if any(emotion.startswith(e.split()[0]) and intensity > 0.6 for e in emergency_emotions):
        try:
            playsound("siren.mp3")
        except Exception:
            print("âš ï¸ Siren playback failed.")
        # Trigger async emergency alert
        threading.Thread(target=send_emergency_alert, args=(emotion,)).start()
        return True
    return False

def send_emergency_alert(emotion):
    # Send Email Alert
    try:
        sender_email = "your_email@gmail.com"
        receiver_email = "caregiver@example.com"
        password = "your_email_password"  # use app password for Gmail

        message = MIMEMultipart("alternative")
        message["Subject"] = "ğŸš¨ Emergency Alert from GADA GUIDE"
        message["From"] = sender_email
        message["To"] = receiver_email

        text = f"Emergency detected! User is feeling {emotion}. Please check immediately."
        # Placeholder for location (if device has GPS integration)
        location = "Location not available"

        part1 = MIMEText(text + "\n" + location, "plain")
        message.attach(part1)

        with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
            server.login(sender_email, password)
            server.sendmail(sender_email, receiver_email, message.as_string())
        print(" Emergency email sent.")
    except Exception as e:
        print(" Emergency email failed:", e)

    # Send SMS via Twilio
    if twilio_client:
        try:
            twilio_client.messages.create(
                body=f"ğŸš¨ Emergency detected! Feeling {emotion}. Location: Not available",
                from_=TWILIO_FROM_NUMBER,
                to=TWILIO_TO_NUMBER
            )
            print("Emergency SMS sent.")
        except Exception as e:
            print(" Emergency SMS failed:", e)

#  Greeting
def get_greeting(msg, emotion="ğŸ˜"):
    try:
        lang = detect(msg)
    except Exception:
        lang = "en"

    greetings = {
        "om": ("Baga Nagaan dhuftan! Akkam jirtu?", {
            "ğŸ˜Š Joy": "Baga gammaddan! ğŸ˜Š",
            "ğŸ˜¢ Sadness": "Boqodhu akkasumas hafuurfadhu. ğŸ›Œ",
            "ğŸ˜ Neutral": "Nagaan sii haa taâ€™u. ğŸ™‚",
            "ğŸ˜  Anger": "Tasgabbiin of eeggadhu. ğŸ§˜â€â™‚ï¸",
            "ğŸ˜¨ Fear": "Waaqa kadhadhu,cimi. ğŸ™"
        }),
        "am": ("á‹°áˆ…áŠ“ áˆ˜áŒ¡á¢ áŠ¥áŠ•á‹´á‰µ áŠá‹?", {
            "ğŸ˜Š Joy": "áŠ¥áŠ•á‹°áˆá‰µáˆ‰áŠ• á‹°áˆµ á‹­á‰ áˆ‹! ğŸ˜Š",
            "ğŸ˜¢ Sadness": "áŠ¥á‰£áŠ­á‹ áŠ¥áˆ¨áá‰µ á‹­á‹áˆ‰á¢ ğŸ›Œ",
            "ğŸ˜ Neutral": "áŠ¥áˆºá£ á‰ áˆáˆµáŒ‹áŠ“! ğŸ™‚",
            "ğŸ˜  Anger": "á‰°áŒ áŠ•á‰€á‰… áŠ¥áŠ“ áŠ áŠ¥áˆáˆ®áŠ• áˆ›áˆµá‰°áŠ«áŠ¨áˆá¢ ğŸ§˜â€â™‚ï¸",
            "ğŸ˜¨ Fear": "áˆˆáŠ¥áŒá‹šáŠ á‰¥áˆ”áˆ­ áŒ¸áˆá‰µá¢ ğŸ™"
        }),

    "en": ("Welcome! How are you?", {
        "ğŸ˜Š Joy": "Great to hear that! ğŸ˜Š",
        "ğŸ˜¢ Sadness": "Take a rest and breathe. ğŸ›Œ",
        "ğŸ˜ Neutral": "Okay. Stay safe! ğŸ™‚",
        "ğŸ˜  Anger": "Try to calm down and meditate. ğŸ§˜â€â™‚ï¸",
        "ğŸ˜¨ Fear": "Pray and stay strong. ğŸ™"
    })

    }

    g, s = greetings.get(lang, greetings["en"])
    return f"{g}\n{s.get(emotion, '')}", lang

#  Offline STT (VOSK)
from vosk import Model, KaldiRecognizer

model_path = "vosk-model-small-en-us-0.15"  # or use absolute path

use_vosk = False
vosk_model = None
recognizer = None
q = queue.Queue()

if os.path.exists(model_path):
    try:
        print("ğŸ§  Loading Vosk model...")
        vosk_model = Model(model_path)
        recognizer = KaldiRecognizer(vosk_model, 16000)

        def callback(indata, frames, time, status):
            q.put(bytes(indata))

        use_vosk = True
        print(" Vosk model loaded successfully.")
    except Exception as e:
        print(f" Failed to load Vosk model: {e}")
        use_vosk = False
else:
    print(f" Vosk model path does not exist: {model_path}")
    use_vosk = False

def recognize_speech_vosk(duration=5):
    with sd.RawInputStream(samplerate=16000, blocksize=8000, dtype='int16',
                           channels=1, callback=callback):
        print("ğŸ¤ Speak now (VOSK)...")
        text = ""
        for _ in range(int(16000 / 8000 * duration)):
            data = q.get()
            if recognizer.AcceptWaveform(data):
                result = json.loads(recognizer.Result())
                text += result.get("text", "")
        return text.strip()

#  Voice Emotion Recognition (Mock)
def analyze_voice_emotion(audio_data=None):
    # Placeholder - in real app, analyze pitch, volume, speed
    # Here just randomly return an emotion and intensity
    emotions = ["ğŸ˜Š Joy", "ğŸ˜¢ Sadness", "ğŸ˜  Anger", "ğŸ˜¨ Fear", "ğŸ˜ Neutral"]
    emotion = random.choice(emotions)
    intensity = random.uniform(0.5, 0.95)
    return emotion, intensity

#  Wellness Tips
WELLNESS_TIPS = {
    "ğŸ˜Š Joy": ["Keep spreading positivity! ğŸŒŸ", "Share your happiness with friends ğŸ˜Š"],
    "ğŸ˜¢ Sadness": ["Try deep breathing exercises ğŸ§˜â€â™‚ï¸", "Listen to your favorite music ğŸµ", "Take a short walk outside ğŸš¶â€â™€ï¸"],
    "ğŸ˜  Anger": ["Count to 10 slowly ğŸ§ ", "Practice meditation ğŸ§˜â€â™‚ï¸", "Write down your feelings âœï¸"],
    "ğŸ˜¨ Fear": ["Talk to a trusted friend or family member ğŸ¤", "Practice grounding techniques ğŸŒ³"],
    "ğŸ˜ Neutral": ["Maintain your routine â°", "Stay hydrated ğŸ’§"]
}

#  Simple Chatbot
CHATBOT_RESPONSES = {
    "hello": "Hello! How are you feeling today? ğŸ˜Š",
    "i am sad": "I'm sorry to hear that. Would you like some wellness tips?",
    "help": "I am here to listen. Tell me more.",
    "bye": "Take care! Remember, I'm always here if you want to talk."
}

def chatbot_response(user_input):
    user_input = user_input.lower()
    for key in CHATBOT_RESPONSES:
        if key in user_input:
            return CHATBOT_RESPONSES[key]
    return "Tell me more about how you're feeling..."

#  Data Privacy: encrypt/decrypt (simple)
from cryptography.fernet import Fernet

def load_or_create_key():
    if os.path.exists("secret.key"):
        with open("secret.key", "rb") as key_file:
            return key_file.read()
    else:
        key = Fernet.generate_key()
        with open("secret.key", "wb") as key_file:
            key_file.write(key)
        return key

FERNET_KEY = load_or_create_key()
fernet = Fernet(FERNET_KEY)

def encrypt_text(text):
    return fernet.encrypt(text.encode()).decode()

def decrypt_text(token):
    try:
        return fernet.decrypt(token.encode()).decode()
    except Exception:
        return "<decryption error>"

#  Gamification
def award_badge(user_email, badge_name):
    conn = sqlite3.connect("gada_guide_logs.db")
    c = conn.cursor()
    # Check if badge already awarded
    c.execute("SELECT id FROM badges WHERE user_email=? AND badge=?", (user_email, badge_name))
    if c.fetchone():
        conn.close()
        return False
    # Award badge
    c.execute("INSERT INTO badges (user_email, badge, awarded_on) VALUES (?, ?, ?)",
              (user_email, badge_name, datetime.now().strftime("%Y-%m-%d")))
    conn.commit()
    conn.close()
    return True

def get_user_badges(user_email):
    conn = sqlite3.connect("gada_guide_logs.db")
    c = conn.cursor()
    c.execute("SELECT badge, awarded_on FROM badges WHERE user_email=?", (user_email,))
    badges = c.fetchall()
    conn.close()
    return badges

#  MainApp Class
class MainApp:
    def __init__(self, root, user_info):
        self.root = root
        self.user_info = user_info
        self.uid = user_info.get("localId")
        self.email = user_info.get("email")
        self.idToken = user_info.get("idToken")

        self.root.title(f"ğŸ§  GADA GUIDE - Offline Wellness Assistant ({self.email})")
        self.root.geometry("800x700")
        self.root.config(bg="#f0f0f8")

        # Variables
        self.current_emotion = "ğŸ˜ Neutral"
        self.current_intensity = 0.5
        self.current_language = "en"
        self.chat_mode = False

        # UI Elements
        self.build_ui()

        init_db()
        self.first_run_check()

        if not os.path.exists("user_logs.csv"):
            with open("user_logs.csv", "w", newline="", encoding="utf-8") as f:
                csv.writer(f).writerow(["Timestamp", "Text", "Emotion", "Intensity", "Language", "Emergency"])

    def build_ui(self):
        tk.Label(self.root, text="ğŸ’¬ Enter your thoughts:", font=("Segoe UI", 16)).pack(pady=12)
        self.entry = tk.Entry(self.root, font=("Segoe UI", 14), width=80)
        self.entry.pack(pady=8)

        btn_frame = tk.Frame(self.root, bg="#f0f0f8")
        btn_frame.pack(pady=10)

        tk.Button(btn_frame, text="ğŸ” Analyze Text", command=self.analyze_input, font=("Segoe UI", 13), bg="#4caf50", fg="white").grid(row=0, column=0, padx=8)
        tk.Button(btn_frame, text="ğŸ¤ Voice Input", command=self.voice_analyze_input, font=("Segoe UI", 13), bg="#2196f3", fg="white").grid(row=0, column=1, padx=8)
        tk.Button(btn_frame, text="ğŸ¤– Chatbot Mode", command=self.toggle_chatbot, font=("Segoe UI", 13), bg="#9c27b0", fg="white").grid(row=0, column=2, padx=8)
        tk.Button(btn_frame, text="ğŸ“Š Mood Trends", command=self.show_mood_trends, font=("Segoe UI", 13), bg="#ff9800", fg="white").grid(row=0, column=3, padx=8)
        tk.Button(btn_frame, text="ğŸ“‚ Logs", command=self.show_logs, font=("Segoe UI", 13), bg="#607d8b", fg="white").grid(row=0, column=4, padx=8)
        tk.Button(btn_frame, text="âš™ï¸ Settings", command=self.show_settings, font=("Segoe UI", 13), bg="#795548", fg="white").grid(row=0, column=5, padx=8)

        # Emoji quick buttons
        symbol_frame = tk.Frame(self.root, bg="#f0f0f8")
        symbol_frame.pack(pady=15)

        quick_msgs = [("ğŸ˜·", "I feel sick"), ("ğŸ§­", "Iâ€™m lost"), ("ğŸ†˜", "I need help"), ("ğŸ—£ï¸", "Can we talk?"), ("ğŸ¤", "I need a friend")]
        for emoji, msg in quick_msgs:
            tk.Button(symbol_frame, text=emoji, font=("Segoe UI Emoji", 18), width=5,
                      command=lambda m=msg: (self.entry.delete(0, tk.END), self.entry.insert(0, m), self.analyze_input())).pack(side=tk.LEFT, padx=6)

        self.label_result = tk.Label(self.root, text="", font=("Segoe UI", 20), fg="#333", bg="#f0f0f8")
        self.label_result.pack(pady=10)

        self.label_advice = tk.Label(self.root, text="", font=("Segoe UI", 14), fg="#555", wraplength=750, bg="#f0f0f8")
        self.label_advice.pack(pady=10)

        self.label_chatbot = tk.Label(self.root, text="", font=("Segoe UI", 14, "italic"), fg="#007acc", wraplength=750, bg="#f0f0f8")
        self.label_chatbot.pack(pady=10)

        self.btn_export_logs = tk.Button(self.root, text="â¬‡ï¸ Export Logs", command=self.export_logs, font=("Segoe UI", 12), bg="#009688", fg="white")
        self.btn_export_logs.pack(side=tk.LEFT, padx=20, pady=10)

        self.btn_delete_logs = tk.Button(self.root, text="ğŸ—‘ï¸ Delete Logs", command=self.delete_logs, font=("Segoe UI", 12), bg="#e53935", fg="white")
        self.btn_delete_logs.pack(side=tk.RIGHT, padx=20, pady=10)

    def first_run_check(self):
        if not os.path.exists("first_run_done.txt"):
            messagebox.showinfo("Welcome to GADA GUIDE",
                                "Thank you for using GADA GUIDE!\n\nType or speak your feelings, "
                                "and I'll help detect your emotion and suggest wellness tips.\n\n"
                                "Emergency alerts will be sent to your caregivers if needed.\n\n"
                                "Let's get started!")
            with open("first_run_done.txt", "w") as f:
                f.write("done")

    def analyze_input(self):
        text = self.entry.get().strip()
        if not text:
            messagebox.showwarning("Input needed", "Please enter your thoughts first.")
            return

        if self.chat_mode:
            # Chatbot mode
            response = chatbot_response(text)
            self.label_chatbot.config(text="ğŸ¤– Chatbot: " + response)
            self.label_result.config(text="")
            self.label_advice.config(text="")
            self.entry.delete(0, tk.END)
            return

        # Language detection
        try:
            detected_lang = detect(text)
        except Exception:
            detected_lang = "en"
        self.current_language = detected_lang

        # Translate to English if needed for emotion detection
        text_for_emotion = translate_text(text, "en")

        emotion, intensity = get_emotion(text_for_emotion)
        self.current_emotion = emotion
        self.current_intensity = intensity

        # Emergency check
        emergency_flag = emergency_check(emotion, intensity)

        # Greeting + wellness tips
        greeting, lang = get_greeting(text, emotion)
        tips = WELLNESS_TIPS.get(emotion, ["Stay positive!"])

        advice = random.choice(tips)
        self.label_result.config(text=f"Detected Emotion: {emotion} (Intensity: {intensity:.2f})")
        self.label_advice.config(text=f"{greeting}\nWellness Tip: {advice}")

        self.label_chatbot.config(text="")
        self.entry.delete(0, tk.END)

        # Save to CSV
        self.save_log(text, emotion, intensity, detected_lang, emergency_flag)

        # Award badges
        if intensity > 0.8:
            badge_awarded = award_badge(self.email, "Expressive User")
            if badge_awarded:
                messagebox.showinfo("ğŸ… Badge Awarded", "You earned the 'Expressive User' badge!")

    def voice_analyze_input(self):
        if use_vosk:
            text = recognize_speech_vosk()
            if not text:
                messagebox.showwarning("Voice input failed", "Could not recognize your speech. Please try again.")
                return
        else:
            messagebox.showinfo("Voice input unavailable", "Offline speech recognition model not found.")
            return

        # Also get mock voice emotion
        voice_emotion, voice_intensity = analyze_voice_emotion()
        self.entry.delete(0, tk.END)
        self.entry.insert(0, text)
        self.analyze_input()
        self.label_result.config(text=f"Text Emotion: {self.current_emotion} | Voice Emotion: {voice_emotion}")

    def save_log(self, text, emotion, intensity, lang, emergency):
        # Save encrypted in SQLite for privacy
        conn = sqlite3.connect("gada_guide_logs.db")
        c = conn.cursor()
        c.execute("INSERT INTO logs (timestamp, text_input, emotion, intensity, language, emergency) VALUES (?, ?, ?, ?, ?, ?)",
                  (datetime.now().isoformat(), encrypt_text(text), emotion, intensity, lang, int(emergency)))
        conn.commit()
        conn.close()

        # Also save plaintext CSV for backup if you want (not encrypted)
        with open("user_logs.csv", "a", newline="", encoding="utf-8") as f:
            csv.writer(f).writerow([datetime.now().isoformat(), text, emotion, intensity, lang, int(emergency)])

    def show_mood_trends(self):
        # Show a simple text-based mood trends (could integrate matplotlib)
        conn = sqlite3.connect("gada_guide_logs.db")
        c = conn.cursor()
        c.execute("SELECT emotion, COUNT(*) FROM logs GROUP BY emotion")
        data = c.fetchall()
        conn.close()

        trend_text = "ğŸ“ˆ Mood Trends Summary:\n"
        total = sum(count for _, count in data)
        for emo, count in data:
            percent = (count / total * 100) if total else 0
            trend_text += f"{emo}: {count} entries ({percent:.1f}%)\n"

        messagebox.showinfo("Mood Trends", trend_text)

    def show_logs(self):
        # Show last 10 logs
        conn = sqlite3.connect("gada_guide_logs.db")
        c = conn.cursor()
        c.execute("SELECT timestamp, text_input, emotion, intensity, language, emergency FROM logs ORDER BY timestamp DESC LIMIT 10")
        rows = c.fetchall()
        conn.close()

        logs_text = "ğŸ—‚ï¸ Last 10 Logs:\n"
        for r in rows:
            timestamp, text_enc, emo, inten, lang, emg = r
            text_dec = decrypt_text(text_enc)
            inten_str = f"{inten:.2f}" if inten is not None else "N/A"
            logs_text += f"{timestamp} | {text_dec} | {emo} ({inten_str}) | Lang: {lang} | Emergency: {'Yes' if emg else 'No'}\n"

        messagebox.showinfo("Logs", logs_text)

    def export_logs(self):
        filepath = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")])
        if filepath:
            conn = sqlite3.connect("gada_guide_logs.db")
            c = conn.cursor()
            c.execute("SELECT timestamp, text_input, emotion, intensity, language, emergency FROM logs ORDER BY timestamp")
            rows = c.fetchall()
            conn.close()
            with open(filepath, "w", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                writer.writerow(["Timestamp", "Text", "Emotion", "Intensity", "Language", "Emergency"])
                for r in rows:
                    text_dec = decrypt_text(r[1])
                    writer.writerow([r[0], text_dec, r[2], r[3], r[4], r[5]])
            messagebox.showinfo("Export Logs", f"Logs exported to {filepath}")

    def delete_logs(self):
        if messagebox.askyesno("Delete Logs", "Are you sure you want to delete all logs? This action cannot be undone."):
            conn = sqlite3.connect("gada_guide_logs.db")
            c = conn.cursor()
            c.execute("DELETE FROM logs")
            conn.commit()
            conn.close()
            messagebox.showinfo("Logs Deleted", "All logs have been deleted.")

    def toggle_chatbot(self):
        self.chat_mode = not self.chat_mode
        if self.chat_mode:
            self.label_chatbot.config(text="ğŸ¤– Chatbot Mode Enabled. Type your messages and I will respond.")
            self.label_result.config(text="")
            self.label_advice.config(text="")
        else:
            self.label_chatbot.config(text="")
            self.label_result.config(text="")
            self.label_advice.config(text="")
        self.entry.delete(0, tk.END)

    def show_settings(self):
        settings_win = tk.Toplevel(self.root)
        settings_win.title("âš™ï¸ Settings")
        settings_win.geometry("400x400")
        tk.Label(settings_win, text="Settings & Privacy", font=("Segoe UI", 16)).pack(pady=10)

        tk.Label(settings_win, text="User Email: " + self.email, font=("Segoe UI", 12)).pack(pady=5)

        badges = get_user_badges(self.email)
        badge_text = "Badges:\n" + "\n".join([f"{b[0]} (Awarded: {b[1]})" for b in badges]) if badges else "No badges earned yet."
        tk.Label(settings_win, text=badge_text, font=("Segoe UI", 12), fg="#4caf50").pack(pady=10)

        tk.Button(settings_win, text="Close", command=settings_win.destroy).pack(pady=20)

# ------------------ Login UI ------------------
def login():
    def try_login():
        email = entry_email.get().strip()
        password = entry_password.get().strip()
        if not email or not password:
            messagebox.showwarning("Input needed", "Please enter both email and password.")
            return

        res = firebase_sign_in(email, password)
        if res:
            messagebox.showinfo("Login Successful", f"Welcome, {email}!")
            login_win.destroy()
            root = tk.Tk()
            app = MainApp(root, res)
            root.mainloop()
        else:
            messagebox.showerror("Login Failed", "Incorrect email or password.")

    login_win = tk.Tk()
    login_win.title("Login to GADA GUIDE")
    login_win.geometry("400x300")
    tk.Label(login_win, text="Email:", font=("Segoe UI", 14)).pack(pady=8)
    entry_email = tk.Entry(login_win, font=("Segoe UI", 14), width=30)
    entry_email.pack(pady=5)
    tk.Label(login_win, text="Password:", font=("Segoe UI", 14)).pack(pady=8)
    entry_password = tk.Entry(login_win, font=("Segoe UI", 14), width=30, show="*")
    entry_password.pack(pady=5)
    tk.Button(login_win, text="Login", font=("Segoe UI", 14), bg="#4caf50", fg="white", command=try_login).pack(pady=20)
    login_win.mainloop()
#  Main
if __name__ == "__main__":
    init_firebase_admin()
    init_db()
    login()
# other modified code 


import subprocess
import csv
import datetime
import os
import random
import sqlite3
import sys
import tempfile
import threading
import tkinter as tk
import webbrowser
from tkinter import messagebox, ttk, filedialog
import cv2
import firebase_admin
import matplotlib.pyplot as plt
import numpy as np
import playsound
import pyttsx3
import speech_recognition as sr
from cryptography.fernet import Fernet
from firebase_admin import credentials, firestore
from gtts import gTTS
from googletrans import Translator
from langdetect import detect
from scipy.signal import find_peaks
#from gui_7th import root
# You need to have these modules in your PYTHONPATH or your project folder
from location.map_helper import show_user_location
from translator.image_ocr import translate_image_text
# --- Globals ---
locked_buttons = []
donation_unlocked = False
USER_PREFERENCES = {}  # cache favorites etc.
# --- Fonts & Styles ---
FONT_LABEL = ("Segoe UI", 14)
FONT_BUTTON = ("Segoe UI Semibold", 16, "bold")
BTN_WIDTH = 25
LOCK_EMOJI = "ğŸ”’"
# --- Load offline tourism data ---
def load_tourism_data():
    # Replace with your actual offline JSON dataset of attractions
    sample_data = [
        {"name": "Blue Nile Falls", "category": "Nature", "city": "Bahirdar",
         "description": "A stunning waterfall on Blue Nile river.", "tips": "Best visited in dry season."},
        {"name": "Lalibela Churches", "category": "Historical", "city": "Lalibela",
         "description": "Rock-hewn churches dating back to 12th century.", "tips": "Wear comfortable shoes."},
        {"name": "Addis Ababa Museum", "category": "Cultural", "city": "Addis Ababa",
         "description": "Learn about Ethiopian history and culture.", "tips": "Closed on Mondays."}
    ]
    return sample_data
TOURISM_DATA = load_tourism_data()
# --- Monetization ---
def open_paypal():
    global donation_unlocked
    webbrowser.open("https://www.paypal.com/donate/?hosted_button_id=YOUR_BUTTON_ID")
    confirm = messagebox.askyesno("Confirm Payment", "Have you completed your donation?")
    if confirm:
        donation_unlocked = True
        unlock_features()
def open_mpesa_info():
    global donation_unlocked
    messagebox.showinfo("M-Pesa / Telebirr Info",
                        "To support us via M-Pesa or Telebirr:\nM-Pesa Number: +2547XXXXXXX\nTelebirr ID: 092XXXXXXX\nThank you!")
    confirm = messagebox.askyesno("Confirm Payment", "Have you completed your payment?")
    if confirm:
        donation_unlocked = True
        unlock_features()
def unlock_features():
    global locked_buttons
    for btn in locked_buttons:
        btn.config(state="normal", text=btn.cget("text").replace(LOCK_EMOJI, "").strip())
    messagebox.showinfo("Thank You!", "Features unlocked! Enjoy GADA GUIDE!")
# --- Encryption ---
def load_or_create_key():
    key_file = "secret.key"
    if os.path.exists(key_file):
        with open(key_file, "rb") as f:
            return f.read()
    else:
        key = Fernet.generate_key()
        with open(key_file, "wb") as f:
            f.write(key)
        return key

FERNET_KEY = load_or_create_key()
fernet = Fernet(FERNET_KEY)

def encrypt_text(text):
    return fernet.encrypt(text.encode()).decode()

def decrypt_text(token):
    try:
        return fernet.decrypt(token.encode()).decode()
    except Exception:
        return "<decryption error>"
# --- Firebase ---
def init_firebase():
    global db
    try:
        cred = credentials.Certificate("firebase_key.json")  # path to your key file
        firebase_admin.initialize_app(cred)
        db = firestore.client()
        print(" Firebase connected.")
    except Exception as e:
        print(" Firebase error:", e)
        db = None  # Ensure db is None on failure
def fetch_firebase_logs():
    global db
    if db is None:
        return " Firebase not initialized."
    try:
        docs = db.collection("emotion_logs").get()
        logs = []
        for doc in docs:
            data = doc.to_dict()
            logs.append({
                "email": data.get("email", "unknown"),
                "emotion": data.get("last_emotion", "N/A"),
                "text": data.get("last_text", ""),
                "timestamp": data.get("timestamp")
            })
        return logs
    except Exception as e:
        return f" Error fetching Firebase logs: {e}"
def save_emotion_to_firebase(email, emotion, text):
    global db
    try:
        doc_ref = db.collection("emotion_logs").document(email)
        doc_ref.set({
            "email": email,
            "last_emotion": emotion,
            "last_text": text,
            "timestamp": firestore.SERVER_TIMESTAMP
        }, merge=True)
        print(f" Data saved for {email}")
    except Exception as e:
        print(" Error saving to Firebase:", e)
def save_user_preferences_to_firebase(email, preferences):
    global db
    try:
        doc_ref = db.collection("user_preferences").document(email)
        doc_ref.set(preferences, merge=True)
        print(f" Preferences saved for {email}")
    except Exception as e:
        print(" Error saving preferences:", e)
# --- Emotion Analysis and Logging ---
def analyze_emotion(text):
    positive = ['happy', 'good', 'great', 'love', 'awesome']
    negative = ['sad', 'bad', 'angry', 'hate', 'terrible']
    t = text.lower()
    if any(word in t for word in positive):
        return "Positive"
    elif any(word in t for word in negative):
        return "Negative"
    else:
        return "Neutral"
def get_emotion(text):
    text = text.lower()
    if any(word in text for word in ["happy", "joy", "love", "glad"]):
        return "happy", random.randint(70, 100)
    elif any(word in text for word in ["sad", "tired", "lonely", "depressed"]):
        return "sad", random.randint(50, 70)
    elif any(word in text for word in ["sick", "pain", "help", "unwell", "hurt"]):
        return "unwell", random.randint(30, 60)
    elif any(word in text for word in ["angry", "mad", "frustrated"]):
        return "angry", random.randint(60, 90)
    else:
        return "neutral", random.randint(60, 80)
def emergency_check(emotion, intensity):
    return emotion == "unwell" and intensity < 50
def log_data(user_email, text, emotion, intensity):
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    encrypted = encrypt_text(f"{text}|{emotion}|{intensity}|{timestamp}")
    with open("user_logs.csv", mode="a", newline="") as file:
        writer = csv.writer(file)
        writer.writerow([user_email, text, emotion, intensity, timestamp])
    conn = sqlite3.connect("gada_guide_logs.db")
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS logs (
                 id INTEGER PRIMARY KEY,
                 user_email TEXT,
                 input_text TEXT,
                 emotion TEXT,
                 intensity INTEGER,
                 encrypted_log TEXT,
                 timestamp TEXT)''')
    c.execute("INSERT INTO logs (user_email, input_text, emotion, intensity, encrypted_log, timestamp) VALUES (?, ?, ?, ?, ?, ?)",
              (user_email, text, emotion, intensity, encrypted, timestamp))
    conn.commit()
    conn.close()
# --- Text-to-Speech ---
def speak(text, lang='en'):
    if lang == 'en':
        engine = pyttsx3.init()
        engine.setProperty('rate', 150)
        voices = engine.getProperty('voices')
        engine.setProperty('voice', voices[0].id)
        engine.say(text)
        engine.runAndWait()
    else:
        try:
            tts = gTTS(text=text, lang=lang)
            with tempfile.NamedTemporaryFile(delete=True, suffix=".mp3") as fp:
                tts.save(fp.name)
                playsound.playsound(fp.name)
        except Exception as e:
            print(f"TTS error: {e}")
            engine = pyttsx3.init()
            engine.say(text)
            engine.runAndWait()
# --- Speak & Translate ---
def speech_to_speech_translate_gui(selected_lang_code):
    recognizer = sr.Recognizer()
    mic = sr.Microphone()
    translator = Translator()

    messagebox.showinfo("Speak Now", "Please speak now. Listening...")

    with mic as source:
        recognizer.adjust_for_ambient_noise(source)
        audio = recognizer.listen(source)

    try:
        spoken_text = recognizer.recognize_google(audio)
    except Exception as e:
        messagebox.showerror("Error", f"Could not understand audio: {e}")
        return

    try:
        detected_lang = translator.detect(spoken_text).lang
    except Exception:
        detected_lang = 'en'  # fallback

    try:
        translated = translator.translate(spoken_text, src=detected_lang, dest=selected_lang_code)
        translated_text = translated.text
    except Exception as e:
        messagebox.showerror("Error", f"Translation failed: {e}")
        return

    messagebox.showinfo("Translation", f"Detected Language: {detected_lang}\n\nOriginal: {spoken_text}\n\nTranslated: {translated_text}")

    try:
        tts = gTTS(text=translated_text, lang=selected_lang_code)
        with tempfile.NamedTemporaryFile(delete=True, suffix=".mp3") as fp:
            tts.save(fp.name)
            playsound.playsound(fp.name)
    except Exception as e:
        messagebox.showerror("Error", f"Text-to-Speech error: {e}")
# --- Translate Image Text ---
def select_image_translate():
    file_path = filedialog.askopenfilename()
    if file_path:
        try:
            lang = 'en'  # or detect(text) if you want dynamic detection
            original, translated = translate_image_text(file_path, lang)
            messagebox.showinfo("Image Translation", f"Original: {original}\n\nTranslated: {translated}")
            speak(translated, lang)
        except Exception as e:
            messagebox.showerror("Error", str(e))
# --- Dummy Pulse and Sensor ---
def analyze_pulse_from_camera(duration=10):
    cap = cv2.VideoCapture(0)
    if not cap.isOpened():
        print(" Webcam not accessible.")
        messagebox.showerror("Error", "Webcam not accessible.")
        return None

    green_intensity = []
    start_time = datetime.datetime.now()

    while (datetime.datetime.now() - start_time).seconds < duration:
        ret, frame = cap.read()
        if not ret:
            break

        h, w, _ = frame.shape
        roi = frame[h//2-50:h//2+50, w//2-50:w//2+50]
        mean_green = np.mean(roi[:, :, 1])
        green_intensity.append(mean_green)

        cv2.rectangle(frame, (w//2-50, h//2-50), (w//2+50, h//2+50), (0, 255, 0), 2)
        cv2.putText(frame, "Place your fingertip or face in the box", (10, 30),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
        cv2.imshow("Pulse Detection", frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    cap.release()
    cv2.destroyAllWindows()

    if len(green_intensity) < 2:
        print(" Not enough data for pulse analysis.")
        messagebox.showerror("Error", "Not enough data for pulse analysis.")
        return None

    signal = np.array(green_intensity)
    signal = (signal - np.mean(signal)) / np.std(signal)
    peaks, _ = find_peaks(signal, distance=15)
    beats = len(peaks)
    bpm = beats * (60 / duration)
    return int(bpm)
def analyze_pulse_thread():
    bpm = analyze_pulse_from_camera()
    if bpm:
        messagebox.showinfo("Pulse Analysis Result", f"Pulse: {bpm} BPM")
def simulate_external_sensor_reading():
    return random.randint(60, 100)
# --- Wellness Heatmap Export ---
def export_wellness_heatmap():
    times = [datetime.datetime.now() - datetime.timedelta(minutes=5*i) for i in reversed(range(10))]
    intensities = [random.randint(40, 100) for _ in range(10)]

    plt.figure(figsize=(10, 5))
    plt.plot(times, intensities, marker='o', linestyle='-', color='blue')
    plt.title("Wellness Intensity Over Time")
    plt.xlabel("Time")
    plt.ylabel("Emotion Intensity (%)")
    plt.grid(True)
    plt.tight_layout()

    save_path = filedialog.asksaveasfilename(defaultextension=".png", filetypes=[("PNG Files","*.png")], title="Save Wellness Heatmap")
    if save_path:
        plt.savefig(save_path)
        messagebox.showinfo("Saved", f"Heatmap saved to {save_path}")
    plt.close()
# --- Analyze Action ---
def analyze_action(email_entry, input_box):
    user_email = email_entry.get().strip()
    text = input_box.get("1.0", tk.END).strip()
    if not user_email or not text:
        messagebox.showwarning("Missing Data", "Please enter your email and how you feel.")
        return
    try:
        lang = detect(text)
    except:
        lang = 'en'
    emotion, intensity = get_emotion(text)
    log_data(user_email, text, emotion, intensity)
    save_emotion_to_firebase(user_email, emotion, text)
    greeting = f"Emotion: {emotion.capitalize()} ({intensity}%)"
    speak(greeting, lang)
    messagebox.showinfo("Analysis Result", greeting)
    if emergency_check(emotion, intensity):
        messagebox.showerror("ğŸš¨ Emergency Alert", "Health warning detected! Seek help immediately.")

# --- New Innovative Features ---
def recommend_attractions(user_emotion, city="Addis Ababa"):
    """Recommend tourist spots based on mood and location (offline dataset)."""
    mood_map = {
        "happy": ["Nature", "Cultural"],
        "sad": ["Nature", "Relaxation"],
        "angry": ["Relaxation"],
        "neutral": ["Historical", "Cultural"],
        "unwell": ["Hospital", "Pharmacy"]
    }
    categories = mood_map.get(user_emotion, ["Cultural"])
    matches = [place for place in TOURISM_DATA if place["city"].lower() == city.lower() and place["category"] in categories]
    if not matches:
        matches = [place for place in TOURISM_DATA if place["city"].lower() == city.lower()]
    return matches[:3]  # top 3

def show_tourism_recommendations(email_entry, input_box):
    user_email = email_entry.get().strip()
    text = input_box.get("1.0", tk.END).strip()
    if not user_email or not text:
        messagebox.showwarning("Missing Data", "Please enter your email and how you feel.")
        return
    emotion, _ = get_emotion(text)
    recs = recommend_attractions(emotion)
    if not recs:
        messagebox.showinfo("No Recommendations", "Sorry, no recommendations available for your area.")
        return
    msg = "Based on your mood, we recommend these places:\n\n"
    for place in recs:
        msg += f"ğŸï¸ {place['name']} ({place['category']}): {place['description']}\nTips: {place['tips']}\n\n"
    messagebox.showinfo("Tourism Recommendations", msg)
    # Save preferences locally & Firebase
    USER_PREFERENCES[user_email] = {"last_recommendations": recs}
    save_user_preferences_to_firebase(user_email, USER_PREFERENCES[user_email])

def open_phrasebook():
    phrasebook = {
        "Hello": {"en": "Hello", "om": "Akkam", "am": "Selam"},
        "Thank you": {"en": "Thank you", "om": "Galatoomi", "am": "Ameseginalehu"},
        "Where is the restroom?": {"en": "Where is the restroom?", "om": "Mana fincaanii eessaa?", "am": "Metsi aydelehonew?"},
        "Help!": {"en": "Help!", "om": "Gargaarsa!", "am": "Aydelem!"},
    }
    pb_win = tk.Toplevel()
    pb_win.title("ğŸ—£ï¸ Multilingual Phrasebook")
    pb_win.geometry("500x300")
    pb_win.configure(bg="#34495E")

    tk.Label(pb_win, text="Phrase", font=FONT_LABEL, bg="#34495E", fg="white").grid(row=0, column=0, padx=10, pady=8)
    tk.Label(pb_win, text="English", font=FONT_LABEL, bg="#34495E", fg="white").grid(row=0, column=1, padx=10, pady=8)
    tk.Label(pb_win, text="Afaan Oromo", font=FONT_LABEL, bg="#34495E", fg="white").grid(row=0, column=2, padx=10, pady=8)
    tk.Label(pb_win, text="Amharic", font=FONT_LABEL, bg="#34495E", fg="white").grid(row=0, column=3, padx=10, pady=8)

    for i, (phrase, translations) in enumerate(phrasebook.items(), start=1):
        tk.Label(pb_win, text=phrase, font=FONT_LABEL, bg="#34495E", fg="white").grid(row=i, column=0, padx=10, pady=6)
        tk.Label(pb_win, text=translations["en"], font=FONT_LABEL, bg="#34495E", fg="white").grid(row=i, column=1, padx=10, pady=6)
        tk.Label(pb_win, text=translations["om"], font=FONT_LABEL, bg="#34495E", fg="white").grid(row=i, column=2, padx=10, pady=6)
        tk.Label(pb_win, text=translations["am"], font=FONT_LABEL, bg="#34495E", fg="white").grid(row=i, column=3, padx=10, pady=6)



def open_streamlit_dashboard():
    """Open Streamlit dashboard in a new browser tab."""
    dashboard_script = os.path.join(os.getcwd(), "streamlit_dashboard.py")
    try:
        subprocess.Popen([sys.executable, "-m", "streamlit", "run", dashboard_script])
        print("Streamlit dashboard launched.")
    except Exception as e:
        print(" Failed to launch Streamlit dashboard:", e)
   # Emotion button
# --- Emotion Input with Voice and Emoji ---
symbols = {
    "ğŸ˜Š Happy": "I feel happy and joyful today!",
    "ğŸ˜¢ Sad": "I feel a bit sad and tired.",
    "ğŸ¤’ Unwell": "I feel sick and need help.",
    "ğŸ˜  Angry": "I feel angry and frustrated.",
    "ğŸ˜ Neutral": "I feel okay, nothing special."
}

emoji_to_text = {label.split()[1].lower(): text for label, text in symbols.items()}

def animate_emoji(emoji_label, emoji):
    for _ in range(3):
        emoji_label.config(text="")
        emoji_label.update()
        threading.Event().wait(0.2)
        emoji_label.config(text=emoji)
        emoji_label.update()
        threading.Event().wait(0.2)

def log_emotion_to_file(text):
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open("emotion_log.txt", "a") as f:
        f.write(f"{timestamp} - {text}\n")

def symbol_input(text, input_box, result_label, emoji_label):
    input_box.delete("1.0", tk.END)
    input_box.insert(tk.END, text)
    result_label.config(text=text)
    emoji = [k for k in symbols if symbols[k] == text][0].split()[0]
    animate_emoji(emoji_label, emoji)
    threading.Thread(target=speak, args=(text,), daemon=True).start()
    log_emotion_to_file(text)
def listen_and_detect(input_box, result_label, emoji_label):
    recognizer = sr.Recognizer()
    with sr.Microphone() as source:
        result_label.config(text="ğŸ¤ Listening...")
        try:
            audio = recognizer.listen(source, timeout=4)
            spoken = recognizer.recognize_google(audio).lower()
            for key in emoji_to_text:
                if key in spoken:
                    symbol_input(emoji_to_text[key], input_box, result_label, emoji_label)
                    return
            result_label.config(text="âš ï¸ Emotion not recognized.")
        except Exception as e:
            result_label.config(text="ğŸ¤ Could not understand.")

def create_main_gui(button_frame=None):
    global locked_buttons
    root = tk.Tk()
    root.title("ğŸ§  GADA GUIDE - Emotion, Wellness & Tourism")
    root.geometry("900x700")
    root.configure(bg="#34495E")
    style = ttk.Style()
    style.theme_use("clam")
    style.configure("TButton", font=FONT_BUTTON, foreground="white", background="#2980B9")
    style.map("TButton",
              foreground=[('pressed', 'white'), ('active', 'white')],
              background=[('pressed', '!disabled', '#1F618D'), ('active', '#2471A3')])

    # User Email
    tk.Label(root, text="Your Email:", font=FONT_LABEL, bg="#34495E", fg="white").grid(row=1, column=0, padx=10, pady=10, sticky="w")
    email_entry = tk.Entry(root, font=FONT_LABEL, width=25)
    email_entry.grid(row=1, column=1, pady=10, sticky="w")
    # Text Input for emotion
    tk.Label(root, text="How do you feel? (Type here ) :",font=FONT_LABEL,bg="#34495E",fg="white").grid(row=2, column=0, padx=10, pady=10, sticky="w")
    input_box = tk.Text(root,height=2, width=35, font=FONT_LABEL)
    input_box.grid(row=2, column=1, padx=10, pady=10)
    # Emoji label and result label
    emoji_label = tk.Label(root, text="", font=("Arial", 36), bg="#34495E")
    emoji_label.grid(row=2, column=2)
    result_label = tk.Label(root, text="", font=("Arial", 12), bg="#34495E", fg="white")
    result_label.grid(row=3, column=1, sticky="w")
    # Analyze Button
    analyze_btn = ttk.Button(root, text=f"Analyze Emotion & Wellness {LOCK_EMOJI}", width=BTN_WIDTH,state="disabled",
                             command=lambda: analyze_action(email_entry, input_box))
    analyze_btn.grid(row=3, column=0, pady=15)
    locked_buttons.append(analyze_btn)
    # Pulse Analysis Button (locked by default)
    pulse_btn = ttk.Button(root, text=f"Analyze Pulse from Camera {LOCK_EMOJI}", width=BTN_WIDTH, state="disabled",
                           command=lambda: threading.Thread(target=analyze_pulse_thread).start())
    pulse_btn.grid(row=5, column=2, pady=15)
    locked_buttons.append(pulse_btn)
    # Wellness Heatmap Export Button (locked)
    heatmap_btn = ttk.Button(root, text=f"Export Wellness Heatmap {LOCK_EMOJI}", width=BTN_WIDTH, state="disabled",
                             command=export_wellness_heatmap)
    heatmap_btn.grid(row=5, column=0, pady=15)
    locked_buttons.append(heatmap_btn)
    # Translate Speech Button
    translate_lang_var = tk.StringVar(value="en")
    lang_choices = {"English": "en", "Afaan Oromo": "om", "Amharic": "am"}
    tk.Label(root, text="Translate Speech To:", font=FONT_LABEL, bg="#34495E", fg="white").grid(row=3, column=1, padx=10, pady=10, sticky="w")
    lang_menu = ttk.Combobox(root, textvariable=translate_lang_var, values=list(lang_choices.keys()), state="readonly", width=33)
    lang_menu.grid(row=3, column=1, padx=10, pady=10, sticky="w")
    def on_translate_speech():
        selected = lang_choices.get(translate_lang_var.get(), "en")
        threading.Thread(target=speech_to_speech_translate_gui, args=(selected,)).start()
    translate_speech_btn = ttk.Button(root,text=f"Speak & Translate to target  {LOCK_EMOJI}",width=BTN_WIDTH, command=on_translate_speech,state="disabled")
    translate_speech_btn.grid(row=3, column=2, pady=15)
    locked_buttons.append(translate_speech_btn)
    # Translate Image Text Button
    img_translate_btn = ttk.Button(root, text=f"Translate Text from Image {LOCK_EMOJI}" ,width=BTN_WIDTH, command=select_image_translate,state="disabled")
    img_translate_btn.grid(row=4, column=2, pady=15)
    locked_buttons.append(img_translate_btn)
    # Tourism Recommendation Button (locked by default)
    tourism_btn = ttk.Button(root, text=f"Get Tourism Recommend- {LOCK_EMOJI}", width=BTN_WIDTH, state="disabled",
                             command=lambda:show_tourism_recommendations(email_entry, input_box))
    tourism_btn.grid(row=4, column=0, pady=15)
    locked_buttons.append(tourism_btn)
    # Phrasebook Button
    phrasebook_btn = ttk.Button(root, text=f"Multilingual Phrasebook {LOCK_EMOJI}" ,width=BTN_WIDTH, command=open_phrasebook,state="disabled")
    phrasebook_btn.grid(row=6, column=2, pady=15)
    locked_buttons.append(phrasebook_btn)
    #pay_frame
    # Monetization Buttons
    pay_frame = tk.Frame(root, bg="#34495E")
    pay_frame.grid(row=0, column=1, pady=20)
    paypal_btn = ttk.Button(root, text="Donate via PayPal ğŸ’³", width=20, command=open_paypal)
    paypal_btn.grid(row=0, column=0, padx=10)
    mpesa_btn = ttk.Button(root, text="Donate via M-Pesa/Telebirr ğŸ’°", width=25, command=open_mpesa_info)
    mpesa_btn.grid(row=0, column=1, padx=10)
    streamlit_dashboard_btn = ttk.Button(root, text=f"ğŸ“Š Open Dashboard  {LOCK_EMOJI}", command=open_streamlit_dashboard,
                                         width=BTN_WIDTH, state="disabled")
    streamlit_dashboard_btn.grid(row=6, column=0, pady=15)
    locked_buttons.append(streamlit_dashboard_btn)
    # FIXED: symbol_input button with proper args
    symbol_input_btn = ttk.Button(
        root,
        text=f"ğŸ˜Š I'm Happy {LOCK_EMOJI}",
        command=lambda: symbol_input(symbols["ğŸ˜Š Happy"], input_box, result_label, emoji_label),
        width=BTN_WIDTH,
        state="disabled"
    )
    symbol_input_btn.grid(row=0, column=2, pady=15)
    locked_buttons.append(symbol_input_btn)
    # Emotion Buttons
    emo_frame = tk.Frame(root, bg="#34495E")
    emo_frame.grid(row=7, column=0, columnspan=3)

    for i, (label, message) in enumerate(symbols.items()):
        btn = ttk.Button(
            emo_frame, text=label,
            command=lambda msg=message: symbol_input(msg, input_box, result_label, emoji_label),
            width=18
        )
        btn.grid(row=i // 3, column=i % 3, padx=5, pady=5)

    # ğŸ™ï¸ Voice Input Button
    voice_btn = ttk.Button(root, text=f"ğŸ™ï¸ Speak Emotion", width=BTN_WIDTH,
                           command=lambda: threading.Thread(
                               target=listen_and_detect,
                               args=(input_box, result_label, emoji_label),
                               daemon=True).start())
    voice_btn.grid(row=8, column=0, columnspan=2, pady=10)
    # Start Firebase
    init_firebase()
    root.mainloop()
# FIXED: Main entry point
if __name__ == "__main__":
    create_main_gui()
